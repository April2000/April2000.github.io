/** !
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function(factory) {
    'use strict';

    if (typeof define === 'function' && define.amd) {
        define(factory);
    }
    else if (typeof module != 'undefined' && typeof module.exports != 'undefined') {
        module.exports = factory();
    }
    else {
        /* jshint sub:true */
        window.Sortable = factory();
    }
}(() => {
    'use strict';

    if (typeof window === 'undefined' || !window.document) {
        return function() {
            throw new Error('Sortable.js requires a window with a document');
        };
    }

    let dragEl;
    let parentEl;
    let ghostEl;
    let rootEl;
    let nextEl;
    let lastDownEl;

    let scrollEl;
    let scrollParentEl;
    let scrollCustomFn;

    let lastEl;
    let lastCSS;
    let lastParentCSS;

    let oldIndex;
    let newIndex;

    let activeGroup;
    let putSortable;

    const autoScroll = {};

    let tapEvt;
    let touchEvt;

    let moved;
    let forRepaintDummy;

    /** @const */
    const R_SPACE = /\s+/g;
    const R_FLOAT = /left|right|inline/;

    const expando = `Sortable${ (new Date()).getTime() }`;

    let captureMode = false;
    let passiveMode = false;

    const supportDraggable = ('draggable' in document.createElement('div'));

    let _silent = false;

    const abs = Math.abs;
    const min = Math.min;

    const savedInputChecked = [];
    const touchDragOverListeners = [];

    const supportCssPointerEvents = (() => {
        // false when IE11
        if (!!navigator.userAgent.match(/trident.*rv[ :]?1{2}\.|msie/i)) {
            return false;
        }

        const el = document.createElement('div');

        el.style.cssText = 'pointer-events: auto';

        return el.style.pointerEvents === 'auto';
    })();

    const _autoScroll = _throttle((evt, options, rootEl, win) => {
        // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
        if (!rootEl || !options.scroll) {
            return false;
        }

        const _this = rootEl[expando];
        const sens  = options.scrollSensitivity;
        const speed = options.scrollSpeed;

        const x = evt.clientX;
        const y = evt.clientY;

        const winWidth = win.innerWidth;
        const winHeight = win.innerHeight;

        let el;
        let rect;
        let vx;
        let vy;

        let scrollOffsetX;
        let scrollOffsetY;

        // Delect scrollEl
        if (scrollParentEl !== rootEl) {
            scrollEl = options.scroll;
            scrollParentEl = rootEl;
            scrollCustomFn = options.scrollFn;

            if (scrollEl === true) {
                scrollEl = rootEl;

                do {
                    if ((scrollEl.offsetWidth < scrollEl.scrollWidth) || (scrollEl.offsetHeight < scrollEl.scrollHeight)) {
                        break;
                    }

                    /* jshint boss:true */
                } while (scrollEl = scrollEl.parentNode);
            }
        }

        if (scrollEl) {
            el = scrollEl;
            rect = scrollEl.getBoundingClientRect();
            vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
            vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
        }


        if (!(vx || vy)) {
            vx = (winWidth - x <= sens) - (x <= sens);
            vy = (winHeight - y <= sens) - (y <= sens);

            /* jshint expr:true */
            (vx || vy) && (el = win);
        }


        if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
            autoScroll.el = el;
            autoScroll.vx = vx;
            autoScroll.vy = vy;

            clearInterval(autoScroll.pid);

            if (el) {
                autoScroll.pid = setInterval(() => {
                    scrollOffsetY = vy ? vy * speed : 0;
                    scrollOffsetX = vx ? vx * speed : 0;

                    if (typeof (scrollCustomFn) === 'function') {
                        if (scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt, touchEvt, el) !== 'continue') {
                            return;
                        }
                    }

                    if (el === win) {
                        win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
                    }
                    else {
                        el.scrollTop += scrollOffsetY;
                        el.scrollLeft += scrollOffsetX;
                    }
                }, 24);
            }
        }
    }, 30);

    function _prepareGroup(options) {
        function toFn(value, pull) {
            if (value == null || value === true) {
                value = group.name;
                if (value == null) {
                    return (() => false);
                }
            }

            if (typeof value === 'function') {
                return value;
            }
            return function(to, from) {
                const fromGroup = from.options.group.name;

                return pull
                    ? value
                    : value && (value.join
                        ? value.indexOf(fromGroup) > -1
                        : (fromGroup == value)
                    );
            };
        }

        let group = {};
        let originalGroup = options.group;

        if (!originalGroup || typeof originalGroup != 'object') {
            originalGroup = { name: originalGroup };
        }

        group.name        = originalGroup.name;
        group.checkPull   = toFn(originalGroup.pull, true);
        group.checkPut    = toFn(originalGroup.put);
        group.revertClone = originalGroup.revertClone;

        options.group = group;
    }

    function _prepareAnimation(options) {
        const defaults = {
            duration: 0,
            delay: 0,
            easing: ''
        };

        const toObj = (value) => {
            if (typeof value !== 'object') {
                return {
                    duration: +value || 0
                };
            }

            return value;
        };

        options.animation            = Object.assign({}, defaults, toObj(options.animation));
        options.ghostAnimation       = Object.assign({}, options.animation, toObj(options.ghostAnimation));
        options.ghostAnimationIn     = Object.assign({}, options.ghostAnimation, toObj(options.ghostAnimationIn));
        options.ghostAnimationOut    = Object.assign({}, options.ghostAnimation, toObj(options.ghostAnimationOut));
        options.placeholderAnimation = Object.assign({}, options.animation, toObj(options.placeholderAnimation));
    }

    // Detect support a passive mode
    try {
        window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
            get() {
                // `false`, because everything starts to work incorrectly and instead of d'n'd,
                // begins the page has scrolled.
                passiveMode = false;
                captureMode = {
                    capture: false,
                    passive: passiveMode
                };
            }
        }));
    }
    catch (err) {}

    /**
     * @class  Sortable
     * @param  {HTMLElement}  el
     * @param  {Object}       [options]
     */
    function Sortable(el, options) {
        if (!(el && el.nodeType && el.nodeType === 1)) {
            throw `Sortable: \`el\` must be HTMLElement, and not ${ {}.toString.call(el) }`;
        }

        // @FLEXBE: doc from owner, fix for iframes
        this.doc = el.ownerDocument;
        this.win = this.doc.defaultView || this.doc.parentWindow;

        this.el = el; // root element
        this.options = options = _extend({}, options);

        // Export instance
        el[expando] = this;

        // Default options
        const defaults = {
            group: null,
            sort: true,
            disabled: false,
            store: null,
            handle: null,
            scroll: true,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            draggable: /[ou]l/i.test(el.nodeName) ? 'li' : '>*',
            placeholderClass: 'sortable-placeholder',
            chosenClass: 'sortable-chosen', // on choose, before move
            dragClass: 'sortable-drag', // on drag
            ghostClass: 'sortable-ghost', // fallbackClass
            ignore: 'a, img',
            filter: null,
            preventOnFilter: true,

            animation: 0, // see _prepareAnimation method
            placeholderAnimation: 0, // inherit from animation
            ghostAnimation: 0, // inherit from animation
            // ghostAnimationIn: 0, // inherit from ghostAnimation
            // ghostAnimationOut: 0, // inherit from ghostAnimation

            setData(dataTransfer, dragEl) {
                dataTransfer.setData('Text', dragEl.textContent);
            },
            instancesBubble: false, // bubble for list in lists
            dropBubble: false,
            dragoverBubble: false,
            dataIdAttr: 'data-id',
            delay: 0,
            forceFallback: false,
            touchStartThreshold: parseInt(this.win.devicePixelRatio, 10) || 1,

            fallbackOnBody: false,
            fallbackOffset: { x: 0, y: 0 },
            fallbackTolerance: 1,
            fallbackScale: 1,
            fallbackOpacity: 0.8,
            fallbackMax: false,
            fallbackDisabled: false,

            disableLayerCheck: false,

            supportPointer: Sortable.supportPointer !== false
        };


        // Set default options
        for (const name in defaults) {
            !(name in options) && (options[name] = defaults[name]);
        }

        _prepareGroup(options);
        _prepareAnimation(options);

        // Bind all private methods
        for (const fn in this) {
            if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
                this[fn] = this[fn].bind(this);
            }
        }

        // Setup drag mode
        this.nativeDraggable = options.forceFallback ? false : supportDraggable;

        // if element or parent has own layer (will-change: transform or transform: translate), position fixed for ghostEl wasn works
        this.hasOwnLayer = (options.forceFallback && !options.fallbackOnBody && !options.disableLayerCheck) ? _hasClosestLayer(el) : false;

        // Bind events
        _on(el, 'mousedown', this._onTapStart);
        _on(el, 'touchstart', this._onTapStart);
        options.supportPointer && _on(el, 'pointerdown', this._onTapStart);

        if (this.nativeDraggable) {
            _on(el, 'dragover', this);
            _on(el, 'dragenter', this);
        }

        this._onDragOver = _throttle(this._onDragOver, 50);

        touchDragOverListeners.push(this._onDragOver);

        // Restore sorting
        options.store && this.sort(options.store.get(this));
    }


    Sortable.prototype = /** @lends Sortable.prototype */ {
        constructor: Sortable,

        _onTapStart(/** Event|TouchEvent */evt) {
            let _this = this,
                el = this.el,
                options = this.options,
                preventOnFilter = options.preventOnFilter,
                type = evt.type,
                touch = evt.touches && evt.touches[0],
                target = (touch || evt).target,
                originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target,
                filter = options.filter,
                startIndex;

            _saveInputCheckedState(el);


            // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
            if (dragEl) {
                return;
            }

            if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
                return; // only left button or enabled
            }

            // cancel dnd if original target is content editable
            if (originalTarget.isContentEditable) {
                return;
            }

            target = _closest(target, options.draggable, el);

            if (!target) {
                return;
            }

            if (lastDownEl === target) {
                // Ignoring duplicate `down`
                return;
            }

            // Get the index of the dragged element within its parent
            startIndex = _index(target, options.draggable);

            // Check filter
            if (typeof filter === 'function') {
                if (filter.call(this, evt, target, this)) {
                    _dispatchEvent(_this, originalTarget, 'filter', target, el, el, startIndex);
                    preventOnFilter && evt.preventDefault();
                    return; // cancel dnd
                }
            }
            else if (filter) {
                filter = filter.split(',').some((criteria) => {
                    criteria = _closest(originalTarget, criteria.trim(), el);

                    if (criteria) {
                        _dispatchEvent(_this, criteria, 'filter', target, el, el, startIndex);
                        return true;
                    }
                });

                if (filter) {
                    preventOnFilter && evt.preventDefault();
                    return; // cancel dnd
                }
            }

            // disable if move not handle
            if (options.handle && !_closest(originalTarget, options.handle, el)) {
                return;
            }
            // Prepare `dragstart`
            this._prepareDragStart(evt, touch, target, startIndex);
        },

        _prepareDragStart(/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
            let _this = this,
                el = _this.el,
                options = _this.options,
                ownerDocument = this.doc,
                dragStartFn;


            if (!target || dragEl || (target.parentNode !== el)) {
                return false;
            }

            tapEvt = evt;

            rootEl = el;
            dragEl = target;
            parentEl = dragEl.parentNode;
            nextEl = dragEl.nextSibling;
            lastDownEl = target;
            activeGroup = options.group;
            oldIndex = startIndex;

            this._lastX = (touch || evt).clientX;
            this._lastY = (touch || evt).clientY;

            dragEl.style['will-change'] = 'all';

            dragStartFn = function() {
                // Delayed drag has been triggered
                // we can re-enable the events: touchmove/mousemove
                _this._disableDelayedDrag();

                // Make the element draggable
                dragEl.draggable = _this.nativeDraggable;

                // Chosen item
                _toggleClass(dragEl, options.dragClass, true);

                // Bind the events: dragstart/dragend
                _this._triggerDragStart(evt, touch);

                // Drag start event
                _dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex);
            };

            // Disable "draggable"
            options.ignore.split(',').forEach((criteria) => {
                _find(dragEl, criteria.trim(), _disableDraggable);
            });

            _on(ownerDocument, 'mouseup', _this._onDrop);
            _on(ownerDocument, 'touchend', _this._onDrop);
            _on(ownerDocument, 'touchcancel', _this._onDrop);
            _on(ownerDocument, 'selectstart', _this);
            options.supportPointer && _on(ownerDocument, 'pointercancel', _this._onDrop);

            if (options.delay) {
                // If the user moves the pointer or let go the click or touch
                // before the delay has been reached:
                // disable the delayed drag
                _on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
                _on(ownerDocument, 'touchend', _this._disableDelayedDrag);
                _on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
                _on(ownerDocument, 'mousemove', _this._disableDelayedDrag);

                _on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
                options.supportPointer && _on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);

                _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
            }
            else {
                dragStartFn();
            }
        },

        /** TouchEvent|PointerEvent */
        _delayedDragTouchMoveHandler(e) {
            if (min(abs(e.clientX - this._lastX), abs(e.clientY - this._lastY)) >= this.options.touchStartThreshold) {
                this._disableDelayedDrag();
            }
        },

        _disableDelayedDrag() {
            const ownerDocument = this.doc;

            clearTimeout(this._dragStartTimer);
            _off(ownerDocument, 'mouseup', this._disableDelayedDrag);
            _off(ownerDocument, 'touchend', this._disableDelayedDrag);
            _off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
            _off(ownerDocument, 'mousemove', this._disableDelayedDrag);
            _off(ownerDocument, 'touchmove', this._disableDelayedDrag);
            _off(ownerDocument, 'pointermove', this._disableDelayedDrag);
        },

        _triggerDragStart(/** Event */evt, /** Touch */touch) {
            touch = touch || (evt.pointerType == 'touch' ? evt : null);

            if (touch) {
                // Touch device support
                tapEvt = {
                    target: dragEl,
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };

                this._onDragStart(tapEvt, 'touch');
            }
            else if (!this.nativeDraggable) {
                this._onDragStart(tapEvt, true);
            }
            else {
                _on(dragEl, 'dragend', this);
                _on(rootEl, 'dragstart', this._onDragStart);
            }


            try {
                if (this.doc.selection) {
                    // Timeout neccessary for IE9
                    _nextTick(() => {
                        this.doc.selection.empty();
                    });
                }
                else {
                    this.win.getSelection().removeAllRanges();
                }
            }
            catch (err) {
            }
        },

        _dragStarted() {
            if (rootEl && dragEl) {
                const options = this.options;

                // Apply effect
                _toggleClass(dragEl, options.placeholderClass, true);
                if (options.placeholderClass !== options.chosenClass) {
                    _toggleClass(dragEl, options.chosenClass, false);
                }

                Sortable.active = this;

                // Drag start event
                _dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex);
            }
            else {
                this._nulling();
            }
        },

        _emulateDragOver() {
            if (touchEvt) {
                if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
                    return;
                }

                this._lastX = touchEvt.clientX;
                this._lastY = touchEvt.clientY;

                // its caused because elementFromPoint ignore css pointerEvents in chrome (sometimes)
                if (!supportCssPointerEvents && !ghostEl.animated) {
                    _css(ghostEl, 'display', 'none');
                }

                // let i = touchDragOverListeners.length;

                let target = this.doc.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
                let parent = target;

                if (target && target.shadowRoot) {
                    target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
                    parent = target;
                }

                let overSortable = false;

                if (parent) {
                    do {
                        if (parent[expando]) {
                            overSortable = true;

                            let i = touchDragOverListeners.length;

                            while (i--) {
                                touchDragOverListeners[i]({
                                    clientX: touchEvt.clientX,
                                    clientY: touchEvt.clientY,
                                    target,
                                    rootEl: parent
                                });
                            }

                            if (!this.options.instancesBubble) {
                                break;
                            }
                        }

                        target = parent; // store last element
                    }
                    /* jshint boss:true */
                    while (parent = parent.parentNode);
                }

                // fix lag with autoScroll
                if (!overSortable) {
                    clearInterval(autoScroll.pid);
                }

                if (!supportCssPointerEvents) {
                    _css(ghostEl, 'display', '');
                }
            }
        },

        _onTouchMove(/** TouchEvent */evt) {
            if (tapEvt) {
                const touch = evt.touches ? evt.touches[0] : evt;

                const fallbackTolerance = this.options.fallbackTolerance;

                // only set the status to dragging, when we are actually dragging
                if (!Sortable.active) {
                    if (fallbackTolerance &&
                        min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
                    ) {
                        return;
                    }

                    this._dragStarted();
                }

                moved = true;
                touchEvt = touch;

                this._appendGhost(touch);
                this._moveGhost(touch);

                evt.preventDefault();
            }
        },

        _appendGhost(evt) {
            const options = this.options;

            if (ghostEl || this.hasOwnLayer || options.fallbackDisabled) {
                return;
            }

            const rect = dragEl.getBoundingClientRect();
            const css = _css(dragEl);

            const fallbackOffset = options.fallbackOffset;

            const clientX = evt.clientX;
            const clientY = evt.clientY;

            const originX = ((clientX - rect.left) / (rect.width)) * 100;
            const originY = ((clientY - rect.top) / (rect.height)) * 100;

            let optimalScale = options.fallbackScale;

            ghostEl = dragEl.cloneNode(true);

            // POSITION
            ghostEl.top  = rect.top - parseInt(css.marginTop, 10) + fallbackOffset.y;
            ghostEl.left = rect.left - parseInt(css.marginLeft, 10) + fallbackOffset.x;

            // CLASSES
            _toggleClass(ghostEl, options.placeholderClass, false);
            // _toggleClass(ghostEl, options.dragClass, false);
            _toggleClass(ghostEl, options.chosenClass, false);
            _toggleClass(ghostEl, options.ghostClass, true);

            // CSS
            _css(ghostEl, 'position', 'fixed', 'important');
            _css(ghostEl, 'zIndex', '100000', 'important');
            _css(ghostEl, 'top', ghostEl.top, 'important');
            _css(ghostEl, 'left', ghostEl.left, 'important');

            _css(ghostEl, 'width', rect.width);
            _css(ghostEl, 'height', rect.height);

            _css(ghostEl, 'pointerEvents', 'none', 'important');
            _css(ghostEl, 'transformOrigin', `${ originX }% ${ originY }%`);

            // APPEND
            if (options.fallbackOnBody) {
                this.doc.body.appendChild(ghostEl);
            }
            else {
                rootEl.appendChild(ghostEl);
            }

            if (options.fallbackMax) {
                // calc max width and height from opts
                optimalScale = Math.min(0.8, options.fallbackMax / Math.min(rect.width, rect.height));
            }

            // animate ghost
            if (!ghostEl.animated) {
                if (options.ghostAnimationIn) {
                    const params = Object.assign({
                        transform: [
                            'scale(1)',
                            `scale(${ optimalScale })`
                        ],
                        opacity: ['1', `${ options.fallbackOpacity }`],
                        reset: false
                    }, this.options.ghostAnimationIn);

                    this._animate(ghostEl, params);
                }
                else {
                    _css(ghostEl, 'transform', `scale(${ optimalScale })`);
                    _css(ghostEl, 'opacity', `${ options.fallbackOpacity }`);
                }
            }
        },

        _moveGhost(evt) {
            if (!tapEvt || !ghostEl) {
                return;
            }

            const dx = (evt.clientX - tapEvt.clientX);
            const dy = (evt.clientY - tapEvt.clientY);

            _css(ghostEl, 'top', ghostEl.top + dy);
            _css(ghostEl, 'left', ghostEl.left + dx);
        },

        _removeGhost(callback = () => {}) {
            if (!ghostEl || !ghostEl.parentNode) {
                callback();
                return;
            }

            const options = this.options;

            // animate ghost
            // !ghostEl.animated
            if (options.ghostAnimationOut && !dragEl.animated) {
                const rect = dragEl.getBoundingClientRect();
                const css  = _css(dragEl);

                const top  = rect.top - parseInt(css.marginTop, 10);
                const left = rect.left - parseInt(css.marginLeft, 10);
                const width  = rect.width;
                const height = rect.height;

                const params = Object.assign({
                    top,
                    left,
                    width,
                    height,
                    transform: 'scale(1)',
                    opacity: 1,
                    reset: false
                }, options.ghostAnimationOut);

                this._animate(ghostEl, params, () => {
                    ghostEl.parentNode.removeChild(ghostEl);
                    callback();
                });
            }
            else {
                ghostEl.parentNode.removeChild(ghostEl);
                callback();
            }
        },

        _onDragStart(/** Event */evt, /** boolean */useFallback) {
            const _this = this;
            const dataTransfer = evt.dataTransfer;
            const options = _this.options;
            const ownerDocument = this.doc;

            _this._offUpEvents();

            _toggleClass(dragEl, options.chosenClass, true);

            if (useFallback) {
                if (options.fallbackTolerance === 0) {
                    this._appendGhost(evt);
                }

                if (useFallback === 'touch') {
                    // Bind touch events
                    _on(ownerDocument, 'touchmove', _this._onTouchMove);
                    _on(ownerDocument, 'touchend', _this._onDrop);
                    _on(ownerDocument, 'touchcancel', _this._onDrop);

                    if (options.supportPointer) {
                        _on(ownerDocument, 'pointermove', _this._onTouchMove);
                        _on(ownerDocument, 'pointerup', _this._onDrop);
                    }
                }
                else {
                    // Old brwoser
                    _on(ownerDocument, 'mousemove', _this._onTouchMove);
                    _on(ownerDocument, 'mouseup', _this._onDrop);
                }

                _this._loopId = setInterval(_this._emulateDragOver, 50);
            }
            else {
                if (dataTransfer) {
                    dataTransfer.effectAllowed = 'move';
                    options.setData && options.setData.call(_this, dataTransfer, dragEl);
                }

                _on(ownerDocument, 'drop', _this);

                // #1143: Бывает элемент с IFrame внутри блокирует `drop`,
                // поэтому если вызвался `mouseover`, значит надо отменять весь d'n'd.
                // Breaking Chrome 62+
                // _on(ownerDocument, 'mouseover', _this);

                _this._dragStartId = _nextTick(_this._dragStarted);
            }
        },

        _onDragOver(evt) {
            // prevent default
            if (evt.preventDefault !== undefined) {
                evt.preventDefault();

                if (!this.options.dragoverBubble) {
                    evt.stopPropagation();
                }
            }

            // start
            moved = true;

            const el = this.el;
            const options = this.options;
            const group   = options.group;

            const isOwner = (activeGroup === group);
            const isMovingBetweenSortable = (putSortable !== this);
            const activeSortable = Sortable.active;

            /* Check if sorting not possible */
            if (!activeSortable || options.disabled || _silent || (isOwner && !options.sort)) {
                return;
            }

            // pull and put check (FIXME not tested)
            if (!isOwner && isMovingBetweenSortable) {
                const pull = activeGroup.checkPull(this, activeSortable, dragEl, evt);
                const put  = group.checkPut(this, activeSortable, dragEl, evt);

                if (!pull || !put) {
                    return;
                }
            }

            // touch fallback (not tested)
            if (evt.rootEl !== undefined && evt.rootEl !== this.el) {
                return;
            }

            // Smart auto-scrolling
            _autoScroll(evt, options, this.el, this.win);

            /* Calculate */
            const dragRect = dragEl.getBoundingClientRect();

            // items in container (exclude ghost)
            const toItems = this.children(el)
                .filter(el => el !== ghostEl)
                .map(el => ({ el, rect : el.getBoundingClientRect() }));

            let fromItems = [];

            let layoutChanged = false;
            let target = _closest(evt.target, options.draggable, el);
            let insertAfter = false;
            let targetRect;

            // Ignore ghost target
            if (target === ghostEl) {
                target = false;
            }

            // Set putMode
            if (isMovingBetweenSortable) {
                // items from
                if (putSortable) {
                    fromItems = putSortable.children(putSortable.el)
                        .filter(el => el !== ghostEl)
                        .map(el => ({ el, rect : el.getBoundingClientRect() }));
                }

                putSortable = this;
            }

            // Move mouse inside container, but not over items (for empty containers or mouseover container padding)
            if (!target && evt.target === el) {
                // Container is empty
                if (toItems.length === 0) {
                    const moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt);

                    if (moveVector !== false) {
                        layoutChanged = this._changeLayout(target, 'append');
                    }
                }
                // Found nearest item
                else {
                    let minDistance = +Infinity;

                    toItems.forEach((item) => {
                        const r = item.rect;
                        const points = [[r.left, r.top], [r.right - 1, r.top], [r.right - 1, r.bottom - 1], [r.left, r.bottom - 1]];

                        points.forEach((point, pindex) => {
                            const x = (point[0] - evt.clientX);
                            const y = (point[1] - evt.clientY);
                            const distance = Math.sqrt(x * x + y * y);

                            if (minDistance > distance) {
                                minDistance = distance;
                                target      = item.el;
                                targetRect  = item.rect;

                                // only for lists
                                insertAfter = pindex >= 2;
                            }
                        });
                    });
                }
            }

            // Change position
            if (!layoutChanged && target && !target.animated && (target !== dragEl) && (target.parentNode[expando] !== undefined)) {
                if (lastEl !== target) {
                    lastEl = target;
                    lastCSS = _css(target);
                    lastParentCSS = _css(target.parentNode);
                }

                if (!targetRect) {
                    targetRect = target.getBoundingClientRect();
                }

                const height = targetRect.height;

                // css position float, display inline or flex-direction: row
                const inRow = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)
                        || (lastParentCSS.display.indexOf('flex') !== -1 && lastParentCSS['flex-direction'].indexOf('row') === 0);

                // all items in same Y line (as list)
                const inVerticalList = toItems.every((item, index) => {
                    return index === 0 || item.rect.left === toItems[index - 1].rect.left;
                });

                // sorting card items (GRID)
                if (inRow && !inVerticalList) {
                    const elTop = dragEl.offsetTop;
                    const tgTop = target.offsetTop;

                    const inLine = (targetRect.top <= dragRect.top && targetRect.bottom >= dragRect.bottom)
                                || (targetRect.top >= dragRect.top && targetRect.bottom <= dragRect.bottom);
                    const isWide = (targetRect.width > dragRect.width);

                    if (inLine) {
                        const halfway = ((evt.clientX - targetRect.left) / targetRect.width) > 0.5;
                        insertAfter = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
                    }
                    // from end element in line to first element in next line and conversly
                    else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
                        insertAfter = (target.previousElementSibling === dragEl);
                    }
                    else {
                        insertAfter = tgTop > elTop;
                    }
                }
                // Sorting INSIDE LIST, smart get position
                else if (!isMovingBetweenSortable) {
                    let isAfter = false;

                    // check what is after target
                    let next = target;
                    while (next = next.nextElementSibling) {
                        if (next === dragEl) {
                            isAfter = true;
                        }
                    }

                    const fix = (height - dragRect.height) / 2;
                    const wayFromTop = !isAfter && (evt.clientY > (targetRect.top + fix));
                    const wayFromBottom = isAfter && (evt.clientY < (targetRect.bottom - fix));

                    // nothing changed
                    if (!wayFromTop && !wayFromBottom) {
                        return;
                    }

                    insertAfter = wayFromTop || !wayFromBottom;
                }
                // Moved from ANOTHER LIST, get insert position
                else {
                    insertAfter = ((evt.clientY - targetRect.top) / height) > 0.5;
                }

                const moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, insertAfter);

                if (moveVector !== false) {
                    if (moveVector === 1 || moveVector === -1) {
                        insertAfter = (moveVector === 1);
                    }

                    layoutChanged = this._changeLayout(target, insertAfter ? 'after' : 'before');
                }
            }

            // something changed, animate items
            if (layoutChanged) {
                parentEl = dragEl.parentNode; // actualization

                // _silent = setTimeout(() => {
                //     _silent = false;
                // }, 80);

                // helper for animate from one rect to another
                const _animateSorting = (target, fromRect, toRect) => {
                    if (!options.animation) {
                        return false;
                    }

                    if (!toRect) {
                        toRect = target.getBoundingClientRect();
                    }

                    const transformX = fromRect.left - toRect.left;
                    const transformY = fromRect.top - toRect.top;

                    if (!transformX && !transformY) {
                        return false;
                    }

                    const params = Object.assign({
                        transform: [
                            `translate3d(${ transformX }px, ${ transformY }px, 0)`,
                            'translate3d(0, 0, 0)'
                        ]
                    }, options.animation);

                    this._animate(target, params);
                };

                const _animateChangeList = (target) => {
                    if (!options.placeholderAnimation) {
                        return false;
                    }

                    const params = Object.assign({
                        opacity: ['0', '1'],
                        transform: [
                            'scale(0.92)',
                            'scale(1)'
                        ]
                    }, options.placeholderAnimation);

                    this._animate(target, params);
                };

                _dispatchEvent(this, rootEl, 'moveEnd', dragEl, parentEl, rootEl, oldIndex, newIndex);

                // sorting in target list
                toItems.forEach((item) => {
                    _animateSorting(item.el, (item.el === dragEl) ? dragRect : item.rect);
                });

                // sorting in from list
                if (isMovingBetweenSortable) {
                    fromItems.forEach((item) => {
                        // dont animate dragEl between lists
                        if (item.el === dragEl) {
                            _animateChangeList(item.el);
                        }
                        else {
                            _animateSorting(item.el, item.rect);
                        }
                    });
                }
            }
        },

        _changeLayout(target, action) {
            const container = this.el;

            if (dragEl.contains(container)) {
                return false;
            }

            if (action === 'after') {
                if (typeof target.after !== 'undefined') {
                    target.after(dragEl);
                    return true;
                }
                else {
                    const nextSibling = target.nextElementSibling;

                    if (!nextSibling) {
                        action = 'append';
                    }
                    else {
                        target.parentNode.insertBefore(dragEl, nextSibling);
                        return true;
                    }
                }
            }

            if (action === 'before') {
                if (typeof target.before !== 'undefined') {
                    target.before(dragEl);
                }

                target.parentNode.insertBefore(dragEl, target);

                return true;
            }

            if (action === 'append') {
                if (container.lastChild && typeof container.lastChild.after !== 'undefined') {
                    container.lastChild.after(dragEl);
                }
                else {
                    container.appendChild(dragEl);
                }

                return true;
            }

            return false;
        },

        /**
         * _animate - Description
         *
         * @param {DOMNode} target  DOM Node
         * @param {Object}  animate Animations, key => [from value, to value]
         */
        _animate(target, params = {}, callback = () => {}) {
            const duration = params.duration || 0;
            const delay    = params.delay || 0;
            const easing   = params.easing;
            const reset    = params.reset;

            const animate = {};
            const ignore = ['transition', 'property', 'duration', 'easing', 'delay', 'reset'];

            // fill animate object, normalize data and remove ignored keys
            Object.keys(params).forEach((key) => {
                if (ignore.includes(key)) {
                    return;
                }

                if (!Array.isArray(params[key])) {
                    animate[key] = ['', params[key]]
                }
                else if (params[key].length < 2) {
                    animate[key] = ['', params[key][0]];
                }
                else {
                    animate[key] = params[key];
                }
            });

            // check if target in animate now and animations is same
            // if (target.animated) {
            //     const oldAnimate = target.animateParams;
            //     const oldAnimateKeys = Object.keys(oldAnimate);
            //     const animateKeys = Object.keys(animate);
            //
            //     const isSame = (animateKeys.length === oldAnimateKeys.length) && animateKeys.every((key) => {
            //         return (oldAnimate[key][1] == animate[key][1]);
            //     });
            //
            //     if (isSame) {
            //         return;
            //     }
            // }

            // create transition prop
            const animatedKeys = Object.keys(animate);
            const transition = animatedKeys.reduce((str, key) => {
                const transition = `${ key } ${ duration }ms ${ easing || '' } ${ delay ? (delay + 'ms') : '' }`;

                return str ? `${ str }, ${ transition }` : transition;
            }, '');

            // INITIAL STATE
            if (duration) {
                _css(target, 'will-change', 'transform');
                _css(target, 'transition', 'none');

                Object.keys(animate).forEach((key) => {
                    if (animate[key][0]) {
                        _css(target, key, animate[key][0]);
                    }
                });

                // cause repaint
                forRepaintDummy = target.offsetWidth;

                _css(target, 'transition', transition, 'important');
            }

            // FINAL STATE
            Object.keys(animate).forEach((key) => {
                _css(target, key, animate[key][1]);
            });

            // WAIT FOR ANIMATION END AND CLEAR STYLE ATTR
            clearTimeout(target.animated);

            // set animatedParams
            target.animateParams = animate;
            target.animated = setTimeout(() => {
                _css(target, 'will-change', '');
                _css(target, 'transition', '');

                if (reset !== false) {
                    Object.keys(animate).forEach((key) => {
                        _css(target, key, '');
                    });
                }

                target.animated = false;
                target.animateParams = false;

                callback();
            }, duration + 20);
        },

        _offUpEvents() {
            const ownerDocument = this.doc;

            _off(document, 'touchmove', this._onTouchMove);
            _off(document, 'pointermove', this._onTouchMove);
            _off(ownerDocument, 'touchmove', this._onTouchMove);
            _off(ownerDocument, 'pointermove', this._onTouchMove);
            _off(ownerDocument, 'mouseup', this._onDrop);
            _off(ownerDocument, 'touchend', this._onDrop);
            _off(ownerDocument, 'pointerup', this._onDrop);
            _off(ownerDocument, 'touchcancel', this._onDrop);
            _off(ownerDocument, 'pointercancel', this._onDrop);
            _off(ownerDocument, 'selectstart', this);
        },

        _onDrop(/** Event */evt) {
            const el = this.el;
            const options = this.options;
            const ownerDocument = this.doc;

            clearInterval(this._loopId);
            clearInterval(autoScroll.pid);
            clearTimeout(this._dragStartTimer);

            _cancelNextTick(this._dragStartId);

            // Unbind events
            _off(ownerDocument, 'mouseover', this);
            _off(ownerDocument, 'mousemove', this._onTouchMove);

            if (this.nativeDraggable) {
                _off(ownerDocument, 'drop', this);
                _off(el, 'dragstart', this._onDragStart);
            }

            this._offUpEvents();

            if (evt) {
                if (moved) {
                    evt.preventDefault();
                    !options.dropBubble && evt.stopPropagation();
                }

                this._removeGhost(() => {
                    if (!dragEl) {
                        return;
                    }

                    if (this.nativeDraggable) {
                        _off(dragEl, 'dragend', this);
                    }

                    _disableDraggable(dragEl);
                    dragEl.style['will-change'] = '';

                    // Remove class's
                    _toggleClass(dragEl, this.options.placeholderClass, false);
                    _toggleClass(dragEl, this.options.chosenClass, false);
                    _toggleClass(dragEl, this.options.dragClass, false);

                    // Drag stop event
                    _dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, evt);

                    if (rootEl !== parentEl) {
                        newIndex = _index(dragEl, options.draggable);

                        if (newIndex >= 0) {
                            // Add event
                            _dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

                            // Remove event
                            _dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

                            // drag from one list and drop into another
                            _dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
                            _dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
                        }
                    }
                    else if (dragEl.nextSibling !== nextEl) {
                        // Get the index of the dragged element within its parent
                        newIndex = _index(dragEl, options.draggable);

                        if (newIndex >= 0) {
                            // drag & drop within the same list
                            _dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
                            _dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);
                        }
                    }

                    if (Sortable.active) {
                        /* jshint eqnull:true */
                        if (newIndex == null || newIndex === -1) {
                            newIndex = oldIndex;
                        }

                        _dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, evt);

                        // Save sorting
                        this.save();
                    }

                    this._nulling();
                });
            }
            else {
                this._nulling();
            }
        },

        _nulling() {
            rootEl =
            dragEl =
            parentEl =
            ghostEl =
            nextEl =
            lastDownEl =

            scrollEl =
            scrollParentEl =

            tapEvt =
            touchEvt =

            moved =
            newIndex =

            lastEl =
            lastCSS =

            putSortable =
            activeGroup =
            Sortable.active = null;

            savedInputChecked.forEach((el) => {
                el.checked = true;
            });
            savedInputChecked.length = 0;
        },

        handleEvent(/** Event */evt) {
            switch (evt.type) {
            case 'drop':
            case 'dragend':
                this._onDrop(evt);
                break;

            case 'dragover':
            case 'dragenter':
                if (dragEl) {
                    this._onDragOver(evt);
                    _globalDragOver(evt);
                }
                break;

            case 'mouseover':
                this._onDrop(evt);
                break;

            case 'selectstart':
                evt.preventDefault();
                break;
            }
        },

        /**
         * Serializes the item into an array of string.
         * @returns {String[]}
         */
        toArray() {
            let order = [],
                el,
                children = this.el.children,
                i = 0,
                n = children.length,
                options = this.options;

            for (; i < n; i++) {
                el = children[i];
                if (_closest(el, options.draggable, this.el)) {
                    order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
                }
            }

            return order;
        },

        /**
         * Sorts the elements according to the array.
         * @param  {String[]}  order  order of the items
         */
        sort(order) {
            let items = {},
                rootEl = this.el;

            this.toArray().forEach(function(id, i) {
                const el = rootEl.children[i];

                if (_closest(el, this.options.draggable, rootEl)) {
                    items[id] = el;
                }
            }, this);

            order.forEach((id) => {
                if (items[id]) {
                    rootEl.removeChild(items[id]);
                    rootEl.appendChild(items[id]);
                }
            });
        },


        /**
         * Save the current sorting
         */
        save() {
            const store = this.options.store;
            store && store.set(this);
        },


        /**
         * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
         * @param   {HTMLElement}  el
         * @param   {String}       [selector]  default: `options.draggable`
         * @returns {HTMLElement|null}
         */
        closest(el, selector) {
            return _closest(el, selector || this.options.draggable, this.el);
        },

        children(el, selector) {
            return _find(el, selector || this.options.draggable);
        },

        /**
         * Set/get option
         * @param   {string} name
         * @param   {*}      [value]
         * @returns {*}
         */
        option(name, value) {
            const options = this.options;

            if (value === void 0) {
                return options[name];
            }

            options[name] = value;

            if (name === 'group') {
                _prepareGroup(options);
            }
        },


        /**
         * Destroy
         */
        destroy() {
            let el = this.el;

            el[expando] = null;

            _off(el, 'mousedown', this._onTapStart);
            _off(el, 'touchstart', this._onTapStart);
            _off(el, 'pointerdown', this._onTapStart);

            if (this.nativeDraggable) {
                _off(el, 'dragover', this);
                _off(el, 'dragenter', this);
            }

            // Remove draggable attributes
            Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), (el) => {
                el.removeAttribute('draggable');
            });

            touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

            this._onDrop();

            this.el = el = null;
        }
    };

    function _closest(/** HTMLElement */el, /** String */selector, /** HTMLElement */ctx) {
        if (el) {
            ctx = ctx || el.ownerDocument;

            do {
                if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
                    return el;
                }
                /* jshint boss:true */
            } while (el = _getParentOrHost(el));
        }

        return null;
    }


    function _getParentOrHost(el) {
        const parent = el.host;

        return (parent && parent.nodeType) ? parent : el.parentNode;
    }


    function _globalDragOver(/** Event */evt) {
        if (evt.dataTransfer) {
            evt.dataTransfer.dropEffect = 'move';
        }
        evt.preventDefault();
    }


    function _on(el, event, fn) {
        el.addEventListener(event, fn, captureMode);
    }


    function _off(el, event, fn) {
        el.removeEventListener(event, fn, captureMode);
    }


    function _toggleClass(el, name, state) {
        if (el) {
            if (el.classList) {
                el.classList[state ? 'add' : 'remove'](name);
            }
            else {
                const className = (` ${ el.className } `).replace(R_SPACE, ' ').replace(` ${ name } `, ' ');
                el.className = (className + (state ? ` ${ name }` : '')).replace(R_SPACE, ' ');
            }
        }
    }

    // zIndex -> z-index
    function _camelToCss(str = '') {
        if (!str) return '';

        return str.split('').map((letter) => {
            const down = letter.toLowerCase();
            if (down !== letter) {
                return `-${ down }`;
            }
            return letter;
        }).join('');
    }

    function _css(el, prop, val, priority = '') {
        const doc = el.ownerDocument;
        const style = el && el.style;

        if (style) {
            if (val === void 0) {
                if (doc.defaultView && doc.defaultView.getComputedStyle) {
                    val = doc.defaultView.getComputedStyle(el, '');
                }
                else if (el.currentStyle) {
                    val = el.currentStyle;
                }

                return prop === void 0 ? val : val[prop];
            }

            if (!(prop in style)) {
                prop = `-webkit-${ prop }`;
            }

            if (typeof val === 'number') {
                val += 'px';
            }

            if (typeof style.setProperty === 'function') {
                style.setProperty(_camelToCss(prop), val, priority);
            }
            else {
                style[prop] = val;
            }
        }
    }


    function _find(ctx, tagName, iterator) {
        if (ctx) {
            const list = Array.from(ctx.querySelectorAll(tagName));
            const n = list.length;

            let i = 0;

            if (iterator) {
                for (; i < n; i++) {
                    iterator(list[i], i);
                }
            }

            return list;
        }

        return [];
    }

    function _closest(/** HTMLElement */el, /** String */selector, /** HTMLElement */ctx) {
        if (el) {
            ctx = ctx || el.ownerDocument;

            do {
                if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
                    return el;
                }
                /* jshint boss:true */
            } while (el = _getParentOrHost(el));
        }

        return null;
    }

    function _hasClosestLayer(el) {
        if (_hasOwnLayer(el)) {
            return true;
        }

        do {
            if (_hasOwnLayer(el)) {
                return 'parent';
            }
        } while (el = _getParentOrHost(el));

        return false;
    }

    function _hasOwnLayer(el) {
        if (el) {
            const transform  = _css(el, 'transform');
            const willChange = _css(el, 'willChange');

            if ((transform && transform !== 'none') || willChange === 'transform') {
                return true;
            }
        }

        return false;
    }


    function _dispatchEvent(sortable, rootEl, name, targetEl, toEl, fromEl, startIndex, newIndex, originalEvt) {
        sortable = (sortable || rootEl[expando]);

        const doc = sortable.doc;
        const options = sortable.options;

        let evt = doc.createEvent('Event'),
            onName = `on${ name.charAt(0).toUpperCase() }${ name.substr(1) }`;

        evt.initEvent(name, true, true);

        evt.to = toEl || rootEl;
        evt.from = fromEl || rootEl;
        evt.item = targetEl || rootEl;

        evt.oldIndex = startIndex;
        evt.newIndex = newIndex;

        evt.originalEvent = originalEvt;

        rootEl.dispatchEvent(evt);

        if (options[onName]) {
            options[onName].call(sortable, evt);
        }
    }


    function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
        let sortable = fromEl[expando],
            onMoveFn = sortable.options.onMove,
            retVal;

        const doc = sortable.doc;
        const evt = doc.createEvent('Event');

        evt.initEvent('move', true, true);

        evt.to = toEl;
        evt.from = fromEl;
        evt.dragged = dragEl;
        evt.draggedRect = dragRect;
        evt.related = targetEl || toEl;
        evt.relatedRect = targetRect || toEl.getBoundingClientRect();
        evt.willInsertAfter = willInsertAfter;

        evt.originalEvent = originalEvt;

        fromEl.dispatchEvent(evt);

        if (onMoveFn) {
            retVal = onMoveFn.call(sortable, evt, originalEvt);
        }

        return retVal;
    }


    function _disableDraggable(el) {
        el.draggable = false;
    }

    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */
    function _generateId(el) {
        let str = el.tagName + el.className + el.src + el.href + el.textContent,
            i = str.length,
            sum = 0;

        while (i--) {
            sum += str.charCodeAt(i);
        }

        return sum.toString(36);
    }

    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */
    function _index(el, selector) {
        let index = 0;

        if (!el || !el.parentNode) {
            return -1;
        }

        while (el && (el = el.previousElementSibling)) {
            if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
                index++;
            }
        }

        return index;
    }

    function _matches(/** HTMLElement */el, /** String */selector) {
        if (el) {
            try {
                if (el.matches) {
                    return el.matches(selector);
                }
                else if (el.msMatchesSelector) {
                    return el.msMatchesSelector(selector);
                }
            }
            catch (_) {
                return false;
            }
        }

        return false;
    }

    function _throttle(callback, delay, noTrailing, debounceMode) {
        var timeoutID;
        var lastExec = 0;


        function wrapper () {
            var self = this;
            var elapsed = Number(new Date()) - lastExec;
            var args = arguments;

            function exec () {
                lastExec = Number(new Date());
                callback.apply(self, args);
            }

            function clear () {
                timeoutID = undefined;
            }

            if ( debounceMode && !timeoutID ) {
                exec();
            }

            if ( timeoutID ) {
                clearTimeout(timeoutID);
            }

            if ( debounceMode === undefined && elapsed > delay ) {
                exec();
            }
            else if ( noTrailing !== true ) {
                timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
            }
        }

        return wrapper;
    }

    function _extend(dst, src) {
        if (dst && src) {
            for (const key in src) {
                if (src.hasOwnProperty(key)) {
                    dst[key] = src[key];
                }
            }
        }

        return dst;
    }

    function _saveInputCheckedState(root) {
        savedInputChecked.length = 0;

        const inputs = root.getElementsByTagName('input');
        let idx = inputs.length;

        while (idx--) {
            const el = inputs[idx];
            el.checked && savedInputChecked.push(el);
        }
    }

    function _nextTick(fn) {
        return setTimeout(fn, 0);
    }

    function _cancelNextTick(id) {
        return clearTimeout(id);
    }

    // Fixed #973:
    _on(document, 'touchmove', (evt) => {
        if (Sortable.active) {
            evt.preventDefault();
        }
    });

    // Export utils
    Sortable.utils = {
        on: _on,
        off: _off,
        css: _css,
        find: _find,
        is(el, selector) {
            return !!_closest(el, selector, el);
        },
        extend: _extend,
        throttle: _throttle,
        closest: _closest,
        toggleClass: _toggleClass,
        index: _index,
        nextTick: _nextTick,
        cancelNextTick: _cancelNextTick
    };

    Sortable.expando = expando;

    /**
     * Create sortable instance
     * @param {HTMLElement}  el
     * @param {Object}      [options]
     */
    Sortable.create = function(el, options) {
        return new Sortable(el, options);
    };


    // Export
    Sortable.version = '1.7.0-flexbe';
    return Sortable;
}));
